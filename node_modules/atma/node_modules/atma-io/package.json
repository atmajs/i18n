{
  "name": "atma-io",
  "description": "File / Directory Classes",
  "author": {
    "name": "Alexander Kit",
    "email": "source.kit@gmail.com"
  },
  "version": "0.1.76",
  "main": "./lib/io.js",
  "repository": {},
  "license": "MIT",
  "dependencies": {
    "atma-logger": "latest",
    "atma-libs": "latest",
    "clean-css": "~1.0.12",
    "coffee-script": "latest",
    "yamljs": "latest",
    "uglify-js": "latest",
    "jshint": "latest"
  },
  "devDependencies": {
    "atma": "latest"
  },
  "scripts": {
    "test": "node_modules/.bin/atma test"
  },
  "readme": "Atma Node.js IO Module\r\n----\r\n[![Build Status](https://travis-ci.org/atmajs/atma-io.svg?branch=master)](https://travis-ci.org/atmajs/atma-io)\r\n\r\nFeatures:\r\n\r\n- File Class\r\n- Directory Class\r\n- File `read/write` Middleware\r\n- Sync\r\n\r\nMostly all operations are synchronous, and this is really useful in case of script applications or desktop applications, where the synchronous performance is not critical.\r\n\r\n\r\n> This library is included into Atma.Toolkit, so creating custom scripts, you can use this API.\r\n\r\n- [File](#file)\r\n    - [API](#file-methods)\r\n    - [Cache](#cache)\r\n    - [Middleware](#file-middleware)\r\n    - [Virtual File](#virtual-files)\r\n- [Directory](#directory)\r\n    - [API](#directory-methods)\r\n\r\n### File\r\n\r\n#### File methods\r\n\r\n##### File constructor\r\n```javascript\r\nvar file = new io.File('test.txt');\r\n```\r\nPath is always relative to the cwd (_except windows os, when drive letter is used_). To specify system absolute path, use `file://` protocol.\r\n\r\n##### read\r\n```javascript\r\nvar content = file.read( <?Object> {\r\n    encoding: String | null, //> 'utf8'\r\n    skipHooks: Boolean //> false\r\n});\r\n```\r\nRead file's content. If `encoding` is set to null raw `Buffer` is returned.\r\nFor each `read` middleware pipeline is used, to skip it, set `skipHooks` to true.\r\n\r\n##### write\r\n```javascript\r\nfile.write(String | Buffer, <?Object>{\r\n    skipHooks: Boolean\r\n});\r\n```\r\n\r\n##### exists\r\n```javascript\r\nfile.exists() //> Boolean;\r\n```\r\n##### copyTo\r\n```javascript\r\nfile.copyTo(<String> location) //> Boolean;\r\n```\r\n##### rename\r\n```javascript\r\nfile.rename(<String> filename)\r\n```\r\n##### remove\r\n```javascript\r\nfile.remove()\r\n```\r\n##### watch\r\n```javascript\r\nfile.watch(callback)\r\n```\r\nWatch file for changes\r\n\r\n##### unwatch\r\n```javascript\r\nfile.unwatch(callback) //> Boolean;\r\n```\r\n\r\n#### Cache\r\nEach `read` will be cached. To control cache behaviour use next methods:\r\n\r\n##### clearCache\r\n```javascript\r\nio.File.clearCache(<?String> path);\r\n```\r\nWhen `path` is `null`, then all cache is dropped.\r\n##### disableCache\r\n```javascript\r\nio.File.disableCache();\r\n```\r\n##### enableCache\r\n```javascript\r\nio.File.disableCache();\r\n```\r\n\r\n#### short forms\r\nThere are some static methods, so that there is no need to initialize the File instance.\r\n```javascript\r\nio.File[method] //> Function(filepath, [..args])\r\n// methods:\r\n        'exists'\r\n        'read'\r\n        'write'\r\n        'remove'\r\n        'copyTo'\r\n```\r\n\r\n### File Middleware\r\nMiddleware pattern is used for all reads and writes. It can be used, for example, to compile coffee script to javascript on the fly. Or when reading `*.yml` file, the resulted content is not a YAML string, but already parsed object.\r\n\r\n#### Extensions\r\n\r\nTo get the idea, look at the hook definition sample:\r\n```javascript\r\nio.File.registerExtensions({\r\n    'coffee':[\r\n        'conditions:read',\r\n        'coffee-compiler:read',\r\n        'uglify:write'\r\n    ]\r\n});\r\n```\r\nEach middleware has unique name and is registerd in this way:\r\n```javascript\r\nio.File.middleware['coffee'] = {\r\n    read: function(<io.File> file, <Object> config){\r\n        var coffee = require('coffee-script');\r\n        file.content = coffee.compile(file.content);\r\n    },\r\n    write: function(<io.File> file, <Object> config){\r\n        // ... do smth with `content` before disk write\r\n    }\r\n};\r\n```\r\n\r\n#### Advanced middleware\r\n```javascript\r\nio\r\n    .File\r\n    .getHookHandler()\r\n    .register({\r\n        regexp: <RegExp>,\r\n        method: <'read'|'write'>,\r\n        handler: <Function | Object> handler,\r\n        zIndex: <?Number> // default: 0\r\n    });\r\n```\r\nPath is matched by the regexp. The greater `zIndex` ist the later it is called in a pipeline, otherwise the handlers are called in the order they were registerd.\r\n\r\n#### Embedded middlewares\r\n_Lately will be converted into plugins, @see [Plugins](#Middleware Plugins)_\r\n- read\r\n    - coffee ( -> javascript )\r\n    - markdown ( -> html )\r\n    - jshint ( -> run jshint )\r\n    - json ( -> JSON.parse is used )\r\n    - yml ( -> YAML parser is used )\r\n    \r\n- write\r\n    - uglify ( -> Minify source before write)\r\n\t- cssmin ( -> Minify source before write)\r\n    - yml ( -> Stringify object to yml string )\r\n    - json ( -> Stringify object to json )\r\n\r\n#### Middleware Plugins\r\nThere additional `read`/`write` middlewares as atma plugins:\r\n\r\n###### `atma plugin install NAME`\r\n\r\n- `atma-loader-traceur` - [Traceur](https://github.com/atmajs/atma-loader-traceur)\r\n- `atma-loader-less` - [Less](https://github.com/atmajs/atma-loader-less)\r\n\r\n\r\n###### Combined middlewares\r\nFor example, you want to use Traceur middelware and jshint for reading `js` files:\r\n_via javascript_\r\n```javascript\r\nio.File.registerExtensions({\r\n\tjs: ['hint:read', 'atma-loader-traceur:read' /* ... */],\r\n})\r\n```\r\n_via `package.json`_\r\n```json\r\n...\r\n\"atma\": {\r\n\t\"settings\" : {\r\n\t\t\"io\": {\r\n\t\t\t\"extensions\": {\r\n\t\t\t\t\"js\": [ \"hint:read\", \"atma-loader-traceur:read\" ]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### **Virtual** Files\r\n\r\nDefine with RegExp a File Handler to completely override  the read/write/exists/remove behaviour.\r\n\r\n```javascript\r\nio\r\n    .File\r\n    .getFactory()\r\n    .registerHandler(/defaults\\.json$/i, Class({\r\n        exists: function(){\r\n            return true;\r\n        },\r\n        read: function(){\r\n            return { foo: 'bar' };\r\n        }\r\n    }));\r\n\r\n```\r\n\r\n\r\n### Directory\r\n\r\n#### Directory methods\r\n\r\n##### Constructor\r\n```javascript\r\nvar dir = new io.Directory('src/');\r\n```\r\nPath is always relative to the cwd (_except windows os, when drive letter is used_). To specify system absolute path, use `file://` protocol.\r\n\r\n##### exists\r\n```javascript\r\ndir.exists()//> Boolean\r\n```\r\n##### readFiles\r\n```javascript\r\ndir.readFiles(<?String> pattern).files // Array<io.Files>\r\n```\r\nGet list of all files in the directory. `pattern` is a glob pattern.\r\n```javascript\r\n// all javascript files, also from sub-directories\r\npattern = '*.js';\r\n// only from base directory\r\npattern = '/*.js'\r\n// only from sub-directories\r\npattern = '**/*.js'\r\n\r\ndir.readFiles(pattern).files\r\n```\r\n\r\n##### copyTo\r\n```javascript\r\ndir.copyTo(<String> destination);\r\n```\r\n\r\n##### rename\r\n```javascript\r\ndir.rename(<String> folderName);\r\n```\r\n\r\n##### remove\r\n```javascript\r\ndir.remove()\r\n```\r\nRemoves all sub directories and all files.\r\n\r\n##### ensure\r\n```javascript\r\ndir.ensure()\r\n```\r\nCreates directory structure, if not already exists.\r\n\r\n##### watch\r\n```javascript\r\ndir.watch(callback)\r\n```\r\nWatch directory for changes\r\n##### unwatch\r\n```javascript\r\ndir.unwatch(callback)\r\n```\r\n\r\n##### short forms\r\nThere are some static methods, so that there is no need to initialize the Directory instance.\r\n```javascript\r\nio.Directory[method] //> Function(dirpath, [..args])\r\n// methods:\r\n    'exists',\r\n    'readFiles',\r\n    'ensure',\r\n    'remove',\r\n    'copyTo'\r\n```\r\n\r\n\r\n----\r\n(c) MIT - Atma.js Project\r\n",
  "readmeFilename": "readme.md",
  "_id": "atma-io@0.1.76",
  "_from": "atma-io@>0.0.41"
}
